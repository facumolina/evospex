package evospex;

import evospex.state.StateSerializer;
import evospex.state.instrumentation.BytecodeUtils;
import evospex.state.instrumentation.Instrumenter;
import evospex.state.mutation.StateMutator;
import org.junit.Test;
import soot.*;
import soot.jimple.*;
import soot.options.Options;

import java.io.FileNotFoundException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * StateGenerator class: allows to serialize states from a given JUnit suite
 */
public class StateGenerator {

  private final String targetMethodSignature;
  private SootClass SOOT_TEST_CLASS;
  private SootMethod SOOT_TARGET_METHOD;
  private int instrumentations = 0;

  /**
   * Setup all the necessary for Soot
   */
  private void setupSoot() {
    // Setup Soot
    G.reset();
    Options.v().set_prepend_classpath(true);
    Options.v().set_allow_phantom_refs(true);
    Options.v().set_soot_classpath(System.getProperty("java.class.path"));
  }

  /**
   * Constructor
   */
  public StateGenerator(String testSuiteClassName, String targetMethodSignature) {
    this.targetMethodSignature = targetMethodSignature;
    // Load the test suite
    try {
      // Load the test class
      Class.forName(testSuiteClassName);
      setupSoot();
      // Load the Soot class
      SOOT_TEST_CLASS = Scene.v().loadClassAndSupport(testSuiteClassName);
      Scene.v().loadClassAndSupport("evospex.state.StateSerializer");
      SOOT_TEST_CLASS.setApplicationClass();
      Scene.v().loadNecessaryClasses();
      try {
        SOOT_TARGET_METHOD = Scene.v().getMethod(targetMethodSignature);
      } catch (RuntimeException e) {
        System.err.println("unable to find method: " + targetMethodSignature);
        // Get the class name from the signature
        String className = targetMethodSignature.substring(1, targetMethodSignature.indexOf(":"));
        System.err.println("possible methods for class " + className + ":");
        for (SootMethod method : Scene.v().getSootClass(className).getMethods()) {
          System.err.println("  " + method.getSignature());
        }
        System.exit(1);
      }
      // Show some info
      System.out.println("target class: "+SOOT_TEST_CLASS.getName());
      System.out.println("target method: "+SOOT_TARGET_METHOD.getSignature());
      System.out.println();
      // Instrument the invocations to the target method
      instrumentInvocationsToTargetMethod();
    } catch (ClassNotFoundException e) {
      System.err.println("The test suite class " + testSuiteClassName + " can't be loaded. Is it in the classpath?");
      System.exit(1);
    }
  }

  /**
   * Instrument all the invocations to the target method within the test class
   */
  private void instrumentInvocationsToTargetMethod() {
    System.out.println("--> target method invocations instrumentation and execution");
    for (SootMethod method : SOOT_TEST_CLASS.getMethods()) {
      performInstrumentation(method);
    }
    System.out.println("invocations instrumented: "+instrumentations);
    System.out.println();
  }

  /**
   * Perform the instrumentation of the given method
   */
  private void performInstrumentation(SootMethod method) {
    // Inspect each unit within the method
    Body methodBody = method.retrieveActiveBody();
    List<Stmt> unitsToInstrument = new ArrayList<>();
    for (Unit unit : methodBody.getUnits()) {
      if (unit instanceof InvokeStmt) {
        InvokeStmt invokeStmt = (InvokeStmt)unit;
        boolean methodMatch = invokeStmt.getInvokeExpr().getMethod().getSignature().equals(targetMethodSignature);
        if (methodMatch) {
          unitsToInstrument.add(invokeStmt);
        }
      }
      if (unit instanceof AssignStmt) {
        AssignStmt assignStmt = (AssignStmt)unit;
        boolean methodMatch = assignStmt.getRightOp() instanceof InvokeExpr && ((InvokeExpr)assignStmt.getRightOp()).getMethod().getSignature().equals(targetMethodSignature);
        if (methodMatch) {
          unitsToInstrument.add(assignStmt);
        }
      }
    }

    // Instrument the invocations
    for (Stmt stmt : unitsToInstrument) {
      instrumentations++;
      Instrumenter.insertCallsToSaveInputState(method, methodBody.getUnits(), stmt);
      Instrumenter.insertCallsToSaveOutputState(method, methodBody.getUnits(), stmt);
    }

  }

  /**
   * Generate the positive states
   * The positive states are generated by running the test suite and serializing objects
   * before and after the invocation of the target method.
   */
  public void generatePositiveStates() throws InstantiationException, IllegalAccessException, FileNotFoundException, ClassNotFoundException {
    // Get the list of test methods
    System.out.println("--> positive states generation");
    Class<?> instrumentedClass = BytecodeUtils.loadAsClass(SOOT_TEST_CLASS);
    List<Method> testMethods = getRunnableTests(instrumentedClass);
    Object testObject = instrumentedClass.newInstance();
    int testsExecuted = 0;
    int errors = 0;
    for (Method testMethod : testMethods) {
      // Run the test method and let the instrumentation collect the created objects
      try {
        Object result = testMethod.invoke(testObject);
        testsExecuted++;
      } catch (Exception e) {
        System.err.println("error running test " + testMethod.getName() + ": "+e.getMessage());
        errors++;
        int inputStatesSaved = StateSerializer.inputsThis.size();
        int outputStatesSaved = StateSerializer.outputsThis.size();
        if (inputStatesSaved > outputStatesSaved) {
          // The target method invocation didn't ended well, so the last input state is not valid and needs to be removed
          StateSerializer.inputsThis.remove(inputStatesSaved - 1);
          for (List<Object> args : StateSerializer.inputsArgs) {
            args.remove(args.size() - 1);
          }
        }
      }
    }
    System.out.println("tests executed: " + testsExecuted);
    System.out.println("errors: " + errors);
    System.out.println("states generated: " + StateSerializer.outputsThis.size());
    System.out.println();
  }

  /**
   * Generate the negative states
   * The negative states are generated by 'mutating' the positive states.
   * Mutation are applied to the objects after the invocation of the target method.
   */
  public void generateNegativeStates() {
    // Load the positive states
    System.out.println("--> negative states generation");
    List<Object> outputStates = StateSerializer.outputsThis;
    int mutationsToPerform = outputStates.size();
    List<Object> outputResultStates = StateSerializer.outputsResult;
    boolean resultsExist = outputResultStates.size() > 0;

    // Generate a negative state from each positive state
    int swaps = 0;
    int fieldMutations = 0;
    for (int i = 0; i < mutationsToPerform; i++) {
      // Get the positive output state
      Object mutatedOutput = StateMutator.mutateState(SOOT_TARGET_METHOD, outputStates, i);
      // Save it to serialized states
      StateSerializer.serializeMutatedObject(0,mutatedOutput, StateMutator.getLastMutation());
      if (resultsExist) {
        Object outputResultState = outputResultStates.get(i);
        StateSerializer.serializeMutatedObject(1, outputResultState, null);
      }
      String lastMutation = StateMutator.getLastMutation();
      if (lastMutation.contains("[Swap Mutation]")) {
        swaps++;
      } else if (lastMutation.contains("[Field Mutation]")) {
        fieldMutations++;
      }
    }
    System.out.println("mutations: " + mutationsToPerform);
    System.out.println("swaps: " + swaps);
    System.out.println("field mutations: " + fieldMutations);
    System.out.println("states generated: " + StateSerializer.mutatedThis.size());
    System.out.println();
  }

  /**
   * Get the list of runnable tests in the given test class
   * A test method is runnable if it is annotated with @Test.
   * @param clazz the test class
   * @return the list of methods corresponding to runnable tests
   */
  private List<Method> getRunnableTests(Class<?> clazz) {
    // Use reflection to find all the JUnit tests in the class
    ArrayList<Method> testMethods = new ArrayList<>();
    for (Method method : clazz.getDeclaredMethods()) {
      if (method.isAnnotationPresent(Test.class)) {
        testMethods.add(method);
      }
    }
    return testMethods;
  }

  /**
   * Get the target method
   * @return the target method
   */
  public SootMethod getTargetMethod() {
    return SOOT_TARGET_METHOD;
  }

  /**
   * Main method
   * @param args the command line arguments: <testSuiteClassName> <targetMethodSignature>
   */
  public static void main(String[] args) {
    if (args.length != 2) {
      System.err.println("Usage: java -cp <cp> evospex.StateGenerator <testSuiteClassName> <targetMethodSignature>");
      System.err.println("provided " + args.length + " args: "+ Arrays.toString(args));
      System.exit(1);
    }
    System.out.println("> State Generation");
    StateGenerator sg = new StateGenerator(args[0], args[1]);
    StateSerializer.setup(sg.getTargetMethod());
    try {
      // Generate the states
      sg.generatePositiveStates();
      sg.generateNegativeStates();
      // Save the serialized states
      StateSerializer.saveSerialization();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
    System.out.println("Done!");
  }

}