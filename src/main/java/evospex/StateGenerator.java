package evospex;

import evospex.state.StateSerializer;
import evospex.state.instrumentation.BytecodeUtils;
import evospex.state.instrumentation.Instrumenter;
import evospex.state.mutation.StateMutator;
import org.junit.Test;
import soot.*;
import soot.jimple.*;
import soot.options.Options;

import java.io.FileNotFoundException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

/**
 * StateGenerator class: allows to serialize states from a given JUnit suite
 */
public class StateGenerator {

  private final String targetMethodSignature;
  private SootClass SOOT_TEST_CLASS;
  private SootMethod SOOT_TARGET_METHOD;

  /**
   * Setup all the necessary for Soot
   */
  private void setupSoot() {
    // Setup Soot
    G.reset();
    Options.v().set_prepend_classpath(true);
    Options.v().set_allow_phantom_refs(true);
    Options.v().set_soot_classpath(System.getProperty("java.class.path"));
  }

  /**
   * Constructor
   */
  public StateGenerator(String testSuiteClassName, String targetMethodSignature) {
    this.targetMethodSignature = targetMethodSignature;
    // Load the test suite
    try {
      // Load the test class
      Class.forName(testSuiteClassName);
      setupSoot();
      // Load the Soot class
      SOOT_TEST_CLASS = Scene.v().loadClassAndSupport(testSuiteClassName);
      Scene.v().loadClassAndSupport("evospex.state.StateSerializer");
      SOOT_TEST_CLASS.setApplicationClass();
      Scene.v().loadNecessaryClasses();
      SOOT_TARGET_METHOD = Scene.v().getMethod(targetMethodSignature);
      // Instrument the invocations to the target method
      instrumentInvocationsToTargetMethod();
    } catch (ClassNotFoundException e) {
      System.err.println("The test suite class " + testSuiteClassName + " can't be loaded. Is it in the classpath?");
      System.exit(1);
    }
  }

  /**
   * Instrument all the invocations to the target method within the test class
   */
  private void instrumentInvocationsToTargetMethod() {
    for (SootMethod method : SOOT_TEST_CLASS.getMethods()) {
      performInstrumentation(method);
    }
  }

  /**
   * Perform the instrumentation of the given method
   */
  private void performInstrumentation(SootMethod method) {
    // Inspect each unit within the method
    Body methodBody = method.retrieveActiveBody();
    List<Stmt> unitsToInstrument = new ArrayList<>();
    for (Unit unit : methodBody.getUnits()) {
      if (unit instanceof InvokeStmt) {
        InvokeStmt invokeStmt = (InvokeStmt)unit;
        boolean methodMatch = invokeStmt.getInvokeExpr().getMethod().getSignature().equals(targetMethodSignature);
        if (methodMatch) {
          unitsToInstrument.add(invokeStmt);
        }
      }
      if (unit instanceof AssignStmt) {
        AssignStmt assignStmt = (AssignStmt)unit;
        boolean methodMatch = assignStmt.getRightOp() instanceof InvokeExpr && ((InvokeExpr)assignStmt.getRightOp()).getMethod().getSignature().equals(targetMethodSignature);
        if (methodMatch) {
          unitsToInstrument.add(assignStmt);
        }
      }
    }
    // Check if target method has a return value
    boolean instrumented = unitsToInstrument.size() > 0;

    for (Stmt stmt : unitsToInstrument) {
      // Check if the invoke stmt has a return value
      Instrumenter.insertCallsToSaveInputState(method, methodBody.getUnits(), stmt);
      Instrumenter.insertCallsToSaveOutputState(method, methodBody.getUnits(), stmt);
    }

    if (instrumented) {
      System.out.println("=====================================");
      System.out.println("Instrumented test method --> : " + method.getName());
      System.out.println(methodBody);
      System.out.println("=====================================");
    }
  }

  /**
   * Generate the positive states
   * The positive states are generated by running the test suite and serializing objects
   * before and after the invocation of the target method.
   */
  public void generatePositiveStates() throws InstantiationException, IllegalAccessException, FileNotFoundException, ClassNotFoundException {
    // Get the list of test methods
    Class<?> instrumentedClass = BytecodeUtils.loadAsClass(SOOT_TEST_CLASS);
    List<Method> testMethods = getRunnableTests(instrumentedClass);
    Object testObject = instrumentedClass.newInstance();

    for (Method testMethod : testMethods) {
      System.out.println("Running test: " + testMethod.getName());
      // Run the test method and collect the created objects
      try {
        Object result = testMethod.invoke(testObject);
      } catch (Exception e) {
        System.err.println("Error running test: " + testMethod.getName());
        e.printStackTrace();
      }
    }
  }

  /**
   * Generate the negative states
   * The negative states are generated by 'mutating' the positive states.
   * Mutation are applied to the objects after the invocation of the target method.
   */
  public void generateNegativeStates() {
    // Load the positive states
    List<Object> outputStates = StateSerializer.outputsThis;
    int mutationsToPerform = outputStates.size();
    List<Object> outputResultStates = StateSerializer.outputsResult;
    boolean resultsExist = outputResultStates.size() > 0;

    // Generate a negative state from each positive state
    for (int i = 0; i < mutationsToPerform; i++) {
      // Get the positive output state
      Object mutatedOutput = StateMutator.mutateState(outputStates, i);
      // Save it to serialized states
      StateSerializer.serializeMutatedObject(0,mutatedOutput);
      if (resultsExist) {
        Object outputResultState = outputResultStates.get(i);
        StateSerializer.serializeMutatedObject(1, outputResultState);
      }
    }
  }

  /**
   * Get the list of runnable tests in the given test class
   * A test method is runnable if it is annotated with @Test.
   * @param clazz the test class
   * @return the list of methods corresponding to runnable tests
   */
  private List<Method> getRunnableTests(Class<?> clazz) {
    // Use reflection to find all the JUnit tests in the class
    ArrayList<Method> testMethods = new ArrayList<>();
    for (Method method : clazz.getDeclaredMethods()) {
      if (method.isAnnotationPresent(Test.class)) {
        testMethods.add(method);
      }
    }
    return testMethods;
  }

  /**
   * Get the target method
   * @return the target method
   */
  public SootMethod getTargetMethod() {
    return SOOT_TARGET_METHOD;
  }

  public static void main(String[] args) {
    if (args.length != 2) {
      System.err.println("Usage: java -cp <cp> evospex.StateGenerator <testSuiteClassName> <targetMethodSignature>");
      System.exit(1);
    }
    StateGenerator sg = new StateGenerator(args[0], args[1]);
    StateSerializer.setup(sg.getTargetMethod());
    try {
      sg.generatePositiveStates();
      sg.generateNegativeStates();
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }

}